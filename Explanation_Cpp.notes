______
C++20 \_________________________________________________________________________

Q> Create an example of an MVVM architecture implemented in C++20 QML and Qt6,
where the model is a simulated EKG of a human heart beat. Use QWT for plotting
the graphs. The view controller allows scrolling and zooming of the rendered
plot and provides a way to measure the heart rate found in the data sample.

A> Certainly! Implementing an MVVM (Model-View-ViewModel) architecture for an
EKG simulation in C++20 with QML and Qt6, including QWT for plotting, involves
a few key components. Below is a simplified example to illustrate how you might
structure such an application.

1. Model

The Model represents the EKG data. For simplicity, we'll simulate some EKG
data.

// ekgmodel.h
#ifndef EKGMODEL_H
#define EKGMODEL_H

#include <QAbstractListModel>
#include <vector>

class EKGModel : public QAbstractListModel
{
    Q_OBJECT
public:
    explicit EKGModel(QObject *parent = nullptr);

    enum Roles {
        ValueRole = Qt::UserRole + 1
    };

    int rowCount(const QModelIndex &parent = QModelIndex()) const override;
    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;
    QHash<int, QByteArray> roleNames() const override;

    void generateData(int points);
    const std::vector<double>& getData() const;

private:
    std::vector<double> m_data;
};

#endif // EKGMODEL_H

// ekgmodel.cpp
#include "ekgmodel.h"
#include <QRandomGenerator>

EKGModel::EKGModel(QObject *parent)
    : QAbstractListModel(parent)
{
    generateData(1000); // Generate initial data
}

int EKGModel::rowCount(const QModelIndex &parent) const
{
    Q_UNUSED(parent);
    return m_data.size();
}

QVariant EKGModel::data(const QModelIndex &index, int role) const
{
    if (!index.isValid() || index.row() >= m_data.size())
        return QVariant();

    if (role == ValueRole)
        return m_data[index.row()];

    return QVariant();
}

QHash<int, QByteArray> EKGModel::roleNames() const
{
    QHash<int, QByteArray> roles;
    roles[ValueRole] = "value";
    return roles;
}

void EKGModel::generateData(int points)
{
    m_data.clear();
    m_data.reserve(points);
    auto rng = QRandomGenerator::global();
    for (int i = 0; i < points; ++i)
    {
        m_data.push_back(rng->bounded(0.0, 1.0));
    }
    emit dataChanged(index(0), index(m_data.size() - 1));
}

const std::vector<double>& EKGModel::getData() const
{
    return m_data;
}

2. ViewModel

The ViewModel provides data for the view and handles interaction logic.

// ekgviewmodel.h
#ifndef EKGVIEWMODEL_H
#define EKGVIEWMODEL_H

#include <QObject>
#include "ekgmodel.h"

class EKGViewModel : public QObject
{
    Q_OBJECT
    Q_PROPERTY(EKGModel* model READ model WRITE setModel NOTIFY modelChanged)
    Q_PROPERTY(double heartRate READ heartRate NOTIFY heartRateChanged)

public:
    explicit EKGViewModel(QObject *parent = nullptr);

    EKGModel* model() const;
    void setModel(EKGModel* model);

    double heartRate() const;

public slots:
    void calculateHeartRate();

signals:
    void modelChanged();
    void heartRateChanged();

private:
    EKGModel* m_model;
    double m_heartRate;
};

#endif // EKGVIEWMODEL_H

// ekgviewmodel.cpp
#include "ekgviewmodel.h"
#include <QDateTime>

EKGViewModel::EKGViewModel(QObject *parent)
    : QObject(parent), m_model(nullptr), m_heartRate(0.0)
{
}

EKGModel* EKGViewModel::model() const
{
    return m_model;
}

void EKGViewModel::setModel(EKGModel* model)
{
    if (m_model != model)
    {
        m_model = model;
        emit modelChanged();
        calculateHeartRate();
    }
}

double EKGViewModel::heartRate() const
{
    return m_heartRate;
}

void EKGViewModel::calculateHeartRate()
{
    if (!m_model)
        return;

    // Simple heart rate calculation based on EKG data
    // Assuming EKG data has peaks every second for simplicity
    int peakCount = 0;
    for (size_t i = 1; i < m_model->getData().size(); ++i)
    {
        if (m_model->getData()[i] > 0.8 && m_model->getData()[i-1] <= 0.8)
        {
            ++peakCount;
        }
    }

    m_heartRate = peakCount * 60.0 / 10; // Assuming 10 seconds of data
    emit heartRateChanged();
}

3. View (QML)

The QML file defines how the data is presented and interacted with.

// Main.qml
import QtQuick 6.0
import QtQuick.Controls 6.0
import Qwt 1.0

ApplicationWindow {
    visible: true
    width: 800
    height: 600
    title: "EKG Simulation"

    EKGViewModel {
        id: viewModel
        model: ekgModel
    }

    EKGModel {
        id: ekgModel
    }

    QwtPlot {
        id: plot
        anchors.fill: parent
        title: "EKG Plot"
        legendVisible: true

        QwtPlotCurve {
            title: "EKG Signal"
            data: QwtData.fromModel(ekgModel)
            pen.color: "blue"
        }

        // Scroll and zoom functionality
        QwtPlotZoomer {
            canvas: plot.canvas
            zoomBase: 2.0
        }

        QwtPlotPanner {
            canvas: plot.canvas
        }

        // Heart rate display
        Text {
            anchors.bottom: parent.bottom
            anchors.horizontalCenter: parent.horizontalCenter
            text: "Heart Rate: " + viewModel.heartRate.toFixed(2) + " BPM"
            font.pointSize: 16
        }
    }
}

4. Main Application

The main application initializes and sets up the Model and ViewModel.

// main.cpp
#include <QApplication>
#include <QQmlApplicationEngine>
#include <QQmlContext>
#include "ekgmodel.h"
#include "ekgviewmodel.h"

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    QQmlApplicationEngine engine;

    EKGModel model;
    EKGViewModel viewModel;

    viewModel.setModel(&model);

    engine.rootContext()->setContextProperty("viewModel", &viewModel);
    engine.rootContext()->setContextProperty("ekgModel", &model);

    engine.load(QUrl(QStringLiteral("qrc:/Main.qml")));
    if (engine.rootObjects().isEmpty())
        return -1;

    return app.exec();
}

Summary

- Model (EKGModel): Holds and provides EKG data.
- ViewModel (EKGViewModel): Contains business logic for calculating heart rate
  and exposes the model to the view.
- View (Main.qml): Defines the user interface using QML and integrates with QWT
  for plotting the EKG data.

Q> Why the roleNames defined as a QHash?

A> In Qt, the QHash<int, QByteArray> is used in conjunction with
QAbstractItemModel to define roles for data access in a model. This mechanism
allows views to request data in different roles, which can be particularly
useful for different types of display or interaction logic in the view.

Here's a detailed explanation of why roleNames is defined as a QHash<int,
QByteArray> and how it fits into the Model-View-Controller (MVC) and
Model-View-ViewModel (MVVM) paradigms:

Purpose of roleNames

1. Role Identification: Each role in the QAbstractItemModel is identified by an
   integer constant. These roles tell the model what type of data to return when
   requested. For example, a ValueRole might be used to get the value of a
   particular item, while another role might be used to get the itemâ€™s label.

2. Role Names: The roleNames function provides a mapping between these integer
   roles and human-readable names. This is particularly useful for debugging and
   for certain views that need to handle data in a more flexible or descriptive
   manner.

3. Flexibility: By defining roles and their names, you allow your model to
   provide various forms of data through different roles. This makes your model
   more flexible and easier to use with different types of views.

Example Usage

Here's a brief example demonstrating how roleNames works:

QHash<int, QByteArray> EKGModel::roleNames() const
{
    QHash<int, QByteArray> roles;
    roles[ValueRole] = "value";
    return roles;
}

In this roleNames function:

- ValueRole: This is an integer constant defined in the model class that acts
  as a key to access specific data from the model.

- "value": This is the human-readable name associated with ValueRole.

When a view, such as a QML component or a Qt widget, requests data from the
model using the ValueRole, it knows how to interpret the integer role because
it can look up the corresponding name using the roleNames function. This
mapping helps the view understand what kind of data it is dealing with and how
to display or process it.

How It Fits in MVVM

In the MVVM architecture:

- Model: Manages the data and defines roles for accessing it. The roleNames
  function ensures that different roles can be easily identified by their
  names, which is useful for both the ViewModel and View.

- ViewModel: Uses the model and its roles to prepare data for the view. The
  ViewModel does not directly deal with the roleNames but relies on the Model
  to provide the necessary data through roles.

- View: Interacts with the model via the ViewModel. It uses the role names to
  request specific pieces of data from the model. For instance, in QML, you
  might use QAbstractItemModel's role names to bind data to UI elements.

By mapping roles to names, the roleNames function provides a clear way to
access and interpret data in the model, making it easier to build complex,
data-driven UIs.

Summary

Defining roleNames as a QHash<int, QByteArray> in a QAbstractItemModel:

- Maps integer role identifiers to descriptive names.
- Enhances the flexibility and readability of data handling in views.
- Facilitates debugging and interaction between the model and the view by
  providing meaningful role names.

This mechanism aligns with the principles of the MVVM pattern by ensuring that
the view (and viewmodel) can access and display data effectively based on
well-defined roles.

